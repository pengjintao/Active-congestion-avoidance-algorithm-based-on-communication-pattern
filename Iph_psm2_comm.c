#include <psm2.h> /* required for core PSM2 functions */
#include <psm2_mq.h>
#include "Iph_Ib_comm.h"
#include <arpa/inet.h>
#include <stdlib.h>
#if HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */
#include <stdio.h>
#include <string.h>
#include <sys/time.h>
#include <unistd.h>
#include <fcntl.h>
#include <vector>
#include <iostream>
#include "IphCommTrace.h"
#include "proc.h"
using namespace std;

int try_to_initialize_psm()
{
    int verno_major = PSM2_VERNO_MAJOR;
    int verno_minor = PSM2_VERNO_MINOR;
    int err = psm2_error_register_handler(NULL,                        //Global handler
                                          PSM2_ERRHANDLER_NO_HANDLER); //return errors
    if (err)
    {
        puts("error 1");
        return -1;
    }
    err = psm2_init(&verno_major, &verno_minor);
    if (err || verno_major > PSM2_VERNO_MAJOR)
    {
        if (err)
            puts("error 2");
        else
            puts("error 3");
        return -1;
    }
    // We were able to initialize PSM2 but defer all further error
    // handling since most of the errors beyond this point are fatal.
    err = psm2_error_register_handler(NULL,                         // Global handler
                                      PSM2_ERRHANDLER_PSM_HANDLER); //
    if (err)
    {
        puts("error 4");
        return -1;
    }
    return 1;
}
// In order to open an endpoint and participate in a job, each endpoint has
// to be distributed a unique 16-byte UUID key from an out-of-band source.
// Presumably this can come from the parallel spawning utility either
// indirectly through an implementors own spawning interface or as in this
// example, the UUID is set as a string in an environment variable
// propagated to all endpoints in the job.
int try_to_open_psm2_endpoint(psm2_ep_t *ep,     // output endpoint handle
                              psm2_epid_t *epid, // output endpoint identifier
                              int unit)          // unit of our choice
{
    struct psm2_ep_open_opts epopts;
    psm2_uuid_t job_uuid;
    char *c;
    // Let PSM2 assign its default values to the endpoint options.
    psm2_ep_open_opts_get_defaults(&epopts);
    // We want a stricter timeout and a specific unit
    epopts.timeout = 15 * 1e9; // 15 second timeout
    epopts.unit = unit;        // We want a specific unit, -1 would let PSM2
    // choose the unit for us.
    // We’ve already set affinity, don’t let PSM2 do so if it wants to.
    if (epopts.affinity == PSM2_EP_OPEN_AFFINITY_SET)
        epopts.affinity = PSM2_EP_OPEN_AFFINITY_SKIP;
    // ENDPOINT_UUID is set to the same value in the environment of all the
    // processes that wish to communicate over PSM2 and was generated by
    // the process spawning utility.
    c = getenv("ENDPOINT_UUID");
    int rc;
    if ((rc = psm2_ep_open(job_uuid, &epopts, ep, epid)) != PSM2_OK)
    {
        printf("couldn't psm2_ep_open() %d", rc);
    }
    return 1;
}
psm2_epid_t find_server()
{
    FILE *fp = NULL;
    psm2_epid_t server_epid = 0;
    //printf("PSM2 client waiting for epid mapping file to appear...\n");
    while (!fp)
    {
        sleep(1);
        fp = fopen("psm2-demo-server-epid", "r");
    }
    fscanf(fp, "%lx", &server_epid);
    fclose(fp);
    printf("PSM2 client found server epid = 0x%lx\n", server_epid);
    return server_epid;
}
void write_epid_to_file(psm2_epid_t myepid)
{
    FILE *fp;
    fp = fopen("psm2-demo-server-epid", "w");
    if (!fp)
    {
        fprintf(stderr,
                "Exiting, couldn't write server's epid mapping file: ");
    }
    fprintf(fp, "0x%lx", myepid);
    fclose(fp);
    //printf("PSM2 server wrote epid = 0x%lx to file.\n", myepid);
    return;
}

void iph_communicate_mpi(int rank,int nproc,MPI_Comm IPH_COMM_WORLD,MPI_Request * req,MPI_Status  * stat);
void iph_communicate(int rank, int nproc,std::vector<int> & out_standing_send, std::vector<int> & out_standing_recv);
psm2_epid_t *epid_array;
psm2_epaddr_t *epaddr_array;
psm2_mq_t msgq;
void iph_psm2_main(char *argv[], int rank, int nprocs, MPI_Comm IPH_COMM_WORLD)
{
    struct psm2_ep_open_opts o;
    psm2_uuid_t uuid;
    psm2_ep_t myep;
    psm2_epid_t myepid;
    psm2_epid_t server_epid;
    epid_array = (psm2_epid_t *)malloc(nprocs * sizeof(psm2_epid_t));
    epaddr_array =(psm2_epaddr_t *)malloc(nprocs * sizeof(psm2_epaddr_t));
    int epid_array_mask[nprocs];
    psm2_error_t epid_connect_errors[nprocs];
    int rc, i;
    int ver_major = PSM2_VERNO_MAJOR;
    int ver_minor = PSM2_VERNO_MINOR;
    int buf_size = 1 << 14;
    int BUFFER_LENGTH = buf_size;
    char *msgbuf = new char[buf_size];    //
    memset(msgbuf, 'a' + rank, buf_size); //[] = "aaaaaaa";
    psm2_mq_req_t req_mq;
    int is_server = rank;

    //puts("lets start");
    memset(uuid, 0, sizeof(psm2_uuid_t)); /* Use a UUID of zero */
    try_to_initialize_psm();
    
    uint32_t availiable_ep = 0;
    if(PSM2_OK == psm2_ep_num_devunits(&availiable_ep))
    {
        //cout<<" availiable_ep = "<<availiable_ep<<endl;
    }

    if ((rc = psm2_ep_open_opts_get_defaults(&o)) != PSM2_OK)
    {
        printf("couldn't set default opts %d", rc);
        return ;
    }
    //printf("PSM2 opts_get_defaults done.\n");
    /* Attempt to open a PSM2 endpoint. This allocates hardware resources. */
    if ((rc = psm2_ep_open(uuid, &o, &myep, &myepid)) != PSM2_OK)
    {
        if (rc == PSM2_TOO_MANY_ENDPOINTS)
            printf("PSM2_TOO_MANY_ENDPOINTS  ");

        printf("couldn't psm2_ep_open() errno = %d return = %d", errno, rc);
        return ;
    }

    // if (is_server)
    // {
    //     //rank = 1
    //     // write_epid_to_file(myepid);
    //     MPI_Send(&myepid,sizeof(myepid),MPI_CHAR,0,0,MPI_COMM_WORLD);
    // }
    // else
    // {
    //     MPI_Status  stat;
    //     MPI_Recv(&server_epid,sizeof(server_epid),MPI_CHAR,1,0,MPI_COMM_WORLD,&stat);
    //     // server_epid = find_server();
    // }
    //利用all-to-all传输每个收集每个端点到自身的消息
    MPI_Allgather(&myepid, sizeof(myepid), MPI_CHAR, epid_array, sizeof(myepid), MPI_CHAR, IPH_COMM_WORLD);
    server_epid = epid_array[1];
    //printf("PSM2 endpoint open done.\n");

    {
        /* Setup connection request info */
        /* PSM2 can connect to a single epid per request,
* or an arbitrary number of epids in a single connect call.
* For this example, use part of an array of
* connection requests. */
        memset(epid_array_mask, 1, sizeof(int) * nprocs);
        // epid_array[0] = server_epid;
        // epid_array_mask[0] = 1;
        if ((rc = psm2_ep_connect(myep,
                                  nprocs,
                                  epid_array,
                                  epid_array_mask,
                                  epid_connect_errors,
                                  epaddr_array,
                                  0 /* no timeout */
                                  )) != PSM2_OK)
        {
            printf("PSM2 connect request processed error.\n");
        }
        //printf("PSM2 connect request processed.\n");
        /* Now check if our connection to the server is ready */
        if (epid_connect_errors[0] != PSM2_OK)
        {
            printf("couldn't connect to server %d",
                   epid_connect_errors[0]);
        }
        //printf("PSM2 client-server connection established.\n");
    }
    /* Setup our PSM2 message queue */
    if ((rc = psm2_mq_init(myep, PSM2_MQ_ORDERMASK_NONE, NULL, 0, &msgq)) != PSM2_OK)
    {
        printf("couldn't initialize PSM2 MQ %d", rc);
    }
    //printf("PSM2 MQ init done.\n");
    if (!is_server)
    {
        snprintf(msgbuf, BUFFER_LENGTH,
                 "Hello world from epid=0x%lx, pid=%d aaaaa.\n",
                 myepid, getpid());
    }
    //点对点通信模式
    if (0)
    {
        //对不同大小的消息

        int loopN = 2;
        MPI_Barrier(IPH_COMM_WORLD);
        MPI_Barrier(IPH_COMM_WORLD);
        double timeS1 = MPI_Wtime();
        //开始循环通信
        //循环10次得到时间结果
        for (i = 0; i < loopN; i++)
        {
            if (rank == 1)
            {
                /* Post the receive request */
                if ((rc = psm2_mq_irecv(msgq,
                                        0xABCD,       /* message tag */
                                        (uint64_t)-1, /* message tag mask */
                                        0,            /* no flags */
                                        msgbuf, BUFFER_LENGTH,
                                        NULL,   /* no context to add */
                                        &req_mq /* track irecv status */
                                        )) != PSM2_OK)
                {
                    printf("couldn't post psm2_mq_irecv()%d ", rc);
                }
                //printf("PSM2 MQ irecv() posted\n");
                /* Wait until the message arrives */
                if ((rc = psm2_mq_wait(&req_mq, NULL)) != PSM2_OK)
                {
                    printf("couldn't wait for the irecv%d ", rc);
                }
                // printf("PSM2 MQ wait() done.\n");
                // printf("Message from client:\n");
                // printf("%s", msgbuf);
                // unlink("psm2-demo-server-epid");
            }
            else if (rank == 0)
            {
                /* Say hello */
                if ((rc = psm2_mq_send(msgq,
                                       epaddr_array[1], //epaddr_array[0], /* destination epaddr */
                                       0,               /* no flags */
                                       0xABCD,          /* tag */
                                       msgbuf, BUFFER_LENGTH)) != PSM2_OK)
                {
                    printf("couldn't post psm2_mq_isend %d", rc);
                }
                //printf("PSM2 MQ send() done.\n");
            }
            MPI_Barrier(IPH_COMM_WORLD);
        }
        MPI_Barrier(IPH_COMM_WORLD);
        double timeE1 = MPI_Wtime();
        for (i = 0; i < loopN; i++)
            MPI_Barrier(IPH_COMM_WORLD);
        double timeEF1 = MPI_Wtime();
        double time1 = (2.0 * timeE1 - timeS1 - timeEF1) / loopN;
        //time1 =   (timeE1 - timeS1)/loopN;
        double re1;
        MPI_Reduce(&time1, &re1, 1, MPI_DOUBLE,
                   MPI_MAX, 0, IPH_COMM_WORLD);
        if (rank == 0)
        {
            // printf("%f\n", time1);
        }
    }
    //warmup
    
    std::vector<int> out_standing_send(msgn);
    std::vector<int> out_standing_recv(msgn);
    if(1)
    {
        MPI_Request * req = new MPI_Request[msgn];
        MPI_Status  * stat = new MPI_Status[msgn];
        for (int loop = 0; loop < 10; loop++)
        {
            iph_communicate(rank, nprocs,out_standing_send,out_standing_recv);
            MPI_Barrier(IPH_COMM_WORLD);
            iph_communicate_mpi(rank, nprocs,IPH_COMM_WORLD,req,stat);
            MPI_Barrier(IPH_COMM_WORLD);
        }
        delete [] req;
        delete [] stat;
    }
    //psm2 Trace 模式
    int loopN = 10;
    if(1)
    {
        MPI_Barrier(IPH_COMM_WORLD);
        MPI_Barrier(IPH_COMM_WORLD);
        double timeS1 = MPI_Wtime();
        for (int loop = 0; loop < loopN; loop++)
        {
            iph_communicate(rank, nprocs,out_standing_send,out_standing_recv);
            MPI_Barrier(IPH_COMM_WORLD);
        }
        MPI_Barrier(IPH_COMM_WORLD);
        double timeE1 = MPI_Wtime();
        for (i = 0; i < loopN; i++)
            MPI_Barrier(IPH_COMM_WORLD);
        double timeEF1 = MPI_Wtime();
        double time1 = (2.0 * timeE1 - timeS1 - timeEF1) / loopN;
        //time1 =   (timeE1 - timeS1)/loopN;
        double re1;
        MPI_Reduce(&time1, &re1, 1, MPI_DOUBLE,
                   MPI_MAX, 0, IPH_COMM_WORLD);
        if (rank == 0)
        {
            printf("%f \t", time1 * 1000000.0);
        }
        /* Close down the MQ */
        if ((rc = psm2_mq_finalize(msgq)) != PSM2_OK)
        {
            printf("couldn't psm2_mq_finalize() %d", rc);
        }
        //printf("PSM2 MQ finalized.\n");
        /* Close our ep, releasing all hardware resources.*/
        /* Try to close all connections properly */
        if ((rc = psm2_ep_close(myep, PSM2_EP_CLOSE_GRACEFUL,
                                0 /* no timeout */)) != PSM2_OK)
        {
            printf("couldn't psm2_ep_close() %d", rc);
        }
        //printf("PSM2 ep closed.\n");
        /* Release all local PSM2 resources */
        if ((rc = psm2_finalize()) != PSM2_OK)
        {
            printf("couldn't psm2_finalize() %d", rc);
        }
        //printf("PSM2 shut down, exiting.\n");
    }

    std::vector<int> ().swap(out_standing_send);
    std::vector<int> ().swap(out_standing_recv);
    //MPI Trace 模式
    if(1)
    {
        MPI_Request * req = new MPI_Request[msgn];
        MPI_Status  * stat = new MPI_Status[msgn];
        MPI_Barrier(IPH_COMM_WORLD);
        MPI_Barrier(IPH_COMM_WORLD);
        double timeS1 = MPI_Wtime();
        for (int loop = 0; loop < loopN; loop++)
        {
            iph_communicate_mpi(rank, nprocs,IPH_COMM_WORLD,req,stat);
            MPI_Barrier(IPH_COMM_WORLD);
        }
        MPI_Barrier(IPH_COMM_WORLD);
        double timeE1 = MPI_Wtime();
        for (i = 0; i < loopN; i++)
            MPI_Barrier(IPH_COMM_WORLD);
        double timeEF1 = MPI_Wtime();
        double time1 = (2.0 * timeE1 - timeS1 - timeEF1) / loopN;
        //time1 =   (timeE1 - timeS1)/loopN;
        double re1;
        MPI_Reduce(&time1, &re1, 1, MPI_DOUBLE,
                   MPI_MAX, 1, IPH_COMM_WORLD);
        if (rank == 0)
        {
            printf("\t%f\n", time1 * 1000000.0);
        }
        delete [] req;
        delete [] stat;
    }

}
void iph_communicate_mpi(int rank,int nproc,MPI_Comm IPH_COMM_WORLD,MPI_Request * req,MPI_Status  * stat)
{
    //compared to mpi
    for(int i = 0;i<msgn;i++)
    {
        if(rank == schd[i].source)
        {
            MPI_Isend(schd[i].bufS,
                        schd[i].size,
                        MPI_CHAR,
                        schd[i].target,
                        (int)schd[i].source*100000+schd[i].target /*tag matching*/,
                        IPH_COMM_WORLD,
                        &req[i]);
        }else{
            MPI_Irecv(schd[i].bufR,
                        schd[i].size,
                        MPI_CHAR,
                        schd[i].source,
                        (int)schd[i].source*100000+schd[i].target /*tag matching*/,
                        IPH_COMM_WORLD,
                        &req[i]);
        }
    }
    for (int i = 0; i < msgn; i++)
    {
        if (MPI_SUCCESS != MPI_Wait(&req[i], &stat[i]))
        {
            printf("error wait %d msgn = %d\n", rank, msgn);
        }
    }
}
void iph_communicate(int rank, int nproc,std::vector<int> & out_standing_send, std::vector<int> & out_standing_recv)
{
    psm2_error_t rc;
    out_standing_send.clear();
    for (int i = 0; i < msgn; i++)
    {
        if (rank == schd[i].source)
        {
            if((rc = psm2_mq_isend(msgq,epaddr_array[schd[i].target],0/* no flags */,
                                    schd[i].source*100000+schd[i].target /*tag matching*/,
                                    schd[i].bufS,schd[i].size,
                                    NULL,&schd[i].req_mq)) != PSM2_OK)
            {
                printf("couldn't post psm2_mq_isend %d", rc);
            }
            if(schd[i].round == 1)
            {
                for(auto & x:out_standing_send)
                    if ((rc = psm2_mq_wait(&schd[x].req_mq, NULL)) != PSM2_OK)
                    {
                        printf("couldn't wait for the isend%d ", rc);
                    } 
            }
            out_standing_send.clear();
            out_standing_send.push_back(i);
        }
        else
        {
            //recv process
            /* Post the receive request */
            if ((rc = psm2_mq_irecv(msgq,
                                    //epaddr_array[schd[i].source],
                                    schd[i].source*100000+schd[i].target /*tag matching*/,  
                                    (uint64_t)-1, /* message tag mask */
                                    0,            /* no flags */
                                    schd[i].bufR, schd[i].size,
                                    NULL,   /* no context to add */
                                    &schd[i].req_mq /* track irecv status */
                                    )) != PSM2_OK)
            {
                printf("couldn't post psm2_mq_irecv()%d ", rc);
            }
            out_standing_recv.push_back(i);
            //printf("PSM2 MQ irecv() posted\n");
        }
    }
    /* Wait until the message arrives */
    for(auto &x:out_standing_send)
    {
        if ((rc = psm2_mq_wait(&schd[x].req_mq, NULL)) != PSM2_OK)
        {
            printf("couldn't wait for the isend%d ", rc);
        } 
    }
    for(auto &x:out_standing_recv)
    {
        if ((rc = psm2_mq_wait(&schd[x].req_mq, NULL)) != PSM2_OK)
        {
            printf("couldn't wait for the irecv%d ", rc);
        } 
    }

}